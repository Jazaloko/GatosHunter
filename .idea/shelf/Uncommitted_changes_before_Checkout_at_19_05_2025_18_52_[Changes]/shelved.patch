Index: app/src/main/java/com/example/gatoshunter/VenderGato.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.gatoshunter\r\n\r\nimport android.os.Bundle\r\nimport android.os.Parcelable\r\nimport android.util.Log\r\nimport android.widget.Button\r\nimport android.widget.TextView\r\nimport android.widget.Toast\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport androidx.lifecycle.lifecycleScope\r\nimport androidx.recyclerview.widget.LinearLayoutManager\r\nimport androidx.recyclerview.widget.RecyclerView\r\nimport com.example.gatoshunter.clases.Comprador\r\nimport com.example.gatoshunter.adaptes.CompradorAdapter\r\nimport com.example.gatoshunter.clases.Gato\r\nimport com.example.gatoshunter.clases.User\r\nimport com.example.miapp.database.DatabaseHelper\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.launch\r\nimport kotlinx.coroutines.withContext\r\nimport java.util.Calendar\r\nimport org.json.JSONObject // Necesitaremos alguna forma de manejar la asociación CompradorId -> GatoName\r\n\r\nclass VenderGato : AppCompatActivity() {\r\n\r\n    private lateinit var dbHelper: DatabaseHelper\r\n\r\n    private lateinit var adapter: CompradorAdapter\r\n    private lateinit var timerTextView: TextView\r\n    private lateinit var temporizadorMedianoche: TemporizadorMedianoche\r\n\r\n    private var currentDailyBuyersList: List<CompradorConGato> = emptyList()\r\n    private var currentUser: User? = null // Variable para almacenar el usuario actual\r\n    // Clave para guardar la asociación CompradorId -> NombreGato interesado para la lista diaria (por usuario)\r\n    private val KEY_DAILY_BUYER_CAT_MAP = \"daily_buyer_cat_map\"\r\n    // Clave base para guardar el timestamp de la última generación (per user)\r\n    private val KEY_LAST_GENERATION_TIMESTAMP_BASE = \"last_generation_timestamp\"\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.vender_gatos)\r\n\r\n        val backButton: Button = findViewById(R.id.backbutton)\r\n        val sellButton: Button = findViewById(R.id.sellbutton)\r\n        timerTextView = findViewById(R.id.temporizador)\r\n\r\n        dbHelper = DatabaseHelper(this)\r\n\r\n        val recyclerView: RecyclerView = findViewById(R.id.recyclerView)\r\n        recyclerView.layoutManager = LinearLayoutManager(this)\r\n        recyclerView.setHasFixedSize(true)\r\n        adapter = CompradorAdapter(emptyList())\r\n        recyclerView.adapter = adapter\r\n\r\n        // Obtener el usuario actual al iniciar la actividad\r\n        lifecycleScope.launch(Dispatchers.IO) {\r\n            // Asumiendo que getAppSharedPreferences() y getUserAsync() existen\r\n            val prefs = applicationContext.getAppSharedPreferences()\r\n            currentUser = prefs.getUserAsync(\"Usuario\")\r\n\r\n            if (currentUser != null) {\r\n                currentDailyBuyersList = loadOrCreateDailyBuyers(currentUser!!)\r\n                withContext(Dispatchers.Main) {\r\n                    adapter.actualizarLista(currentDailyBuyersList)\r\n                }\r\n            } else {\r\n                // Manejar el caso donde no se pudo obtener el usuario\r\n                withContext(Dispatchers.Main) {\r\n                    Toast.makeText(this@VenderGato, \"Error: No se pudo cargar el usuario.\", Toast.LENGTH_LONG).show()\r\n                    finish() // Cerrar la actividad si no hay usuario\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        //Botones\r\n        backButton.setOnClickListener { finish() }\r\n\r\n        sellButton.setOnClickListener { resolverVenta() }\r\n\r\n        // Timer\r\n        temporizadorMedianoche = TemporizadorMedianoche(timerTextView) {\r\n            lifecycleScope.launch(Dispatchers.IO) {\r\n                // Pasar el usuario actual para resetear los compradores vendidos de ese usuario\r\n                currentUser?.let { user ->\r\n                    updateRecyclerViewData(user)\r\n                } ?: run {\r\n                    // Manejar caso sin usuario si el timer se dispara antes\r\n                    Log.e(\"VenderGato\", \"Temporizador de medianoche activado sin usuario.\")\r\n                }\r\n            }\r\n        }\r\n        temporizadorMedianoche.iniciar()\r\n    }\r\n\r\n    data class CompradorConGato(val comprador: Comprador, val nombreGatoInteres: String?)\r\n\r\n    //Cargar compradores diarios o crear si es un nuevo día. Ahora requiere el usuario y usa la DB.\r\n    private fun loadOrCreateDailyBuyers(user: User): List<CompradorConGato> {\r\n        // Pass the user's ID here!\r\n        val lastTimestamp = cargarUltimaGeneracionTimestamp(user.id!!)\r\n        val currentCalendar = Calendar.getInstance()\r\n        val lastGenerationCalendar = Calendar.getInstance().apply { timeInMillis = lastTimestamp }\r\n\r\n        val isSameDay = lastTimestamp != 0L &&\r\n                currentCalendar.get(Calendar.YEAR) == lastGenerationCalendar.get(Calendar.YEAR) &&\r\n                currentCalendar.get(Calendar.DAY_OF_YEAR) == lastGenerationCalendar.get(Calendar.DAY_OF_YEAR)\r\n\r\n        return if (isSameDay) {\r\n            // Si es el mismo día, carga los compradores desde la tabla CompradorUser para este usuario\r\n            Log.d(\"VenderGato\", \"Mismo día para usuario ${user.id}. Cargando compradores desde DB.\")\r\n            val compradoresDelDiaDB = dbHelper.obtenerCompradoresDiariosByUser(user)\r\n\r\n            // Carga el mapa de asociación CompradorId -> NombreGato para el día desde SharedPreferences (already user-specific)\r\n            val buyerCatMap = cargarDailyBuyerCatMap(user.id!!)\r\n\r\n            // Combina los compradores de la DB con los nombres de gatos de SharedPreferences\r\n            compradoresDelDiaDB.mapNotNull { comprador ->\r\n                val catName = buyerCatMap[comprador.id.toString()]\r\n                if (catName != null) {\r\n                    CompradorConGato(comprador, catName)\r\n                } else {\r\n                    Log.w(\"VenderGato\", \"No se encontró nombre de gato para comprador ${comprador.id} en el mapa del día de usuario ${user.id}.\")\r\n                    null\r\n                }\r\n            }.also {\r\n                Log.d(\"VenderGato\", \"Compradores cargados para usuario ${user.id}: ${it.size}\")\r\n            }\r\n\r\n        } else {\r\n            Log.d(\"VenderGato\", \"Nuevo día o no timestamp para usuario ${user.id}. Generando nuevos compradores y actualizando DB.\")\r\n            selectAndSaveNewDailyBuyers(user) // selectAndSaveNewDailyBuyers will call guardarUltimaGeneracionTimestamp with the user ID\r\n        }\r\n    }\r\n\r\n\r\n    // Selecciona 3 compradores aleatorios, los añade a CompradorUser para el usuario,\r\n    // asigna gatos aleatorios y guarda la asociación en SharedPreferences.\r\n    // También actualiza el timestamp.\r\n    private fun selectAndSaveNewDailyBuyers(user: User): List<CompradorConGato> {\r\n        // Vacía la tabla CompradorUser para este usuario al inicio de un nuevo día\r\n        dbHelper.eliminarCompradoresDiariosDeUsuario(user.id!!)\r\n        Log.d(\"VenderGato\", \"Tabla CompradorUser vaciada para usuario ${user.id} al inicio del día.\")\r\n\r\n        val allPotentialBuyers = dbHelper.obtenerCompradores() // Get ALL potential buyers from main DB table\r\n        val allPotentialGatos = dbHelper.obtenerGatos() // Get ALL potential gatos from main DB table\r\n\r\n        // Ensure we don't select more buyers/gatos than available\r\n        val numberOfItemsToSelect = minOf(3, allPotentialBuyers.size, allPotentialGatos.size)\r\n        val selectedBuyers = allPotentialBuyers.shuffled().take(numberOfItemsToSelect)\r\n        val selectedGatos = allPotentialGatos.shuffled().take(numberOfItemsToSelect)\r\n\r\n        val compradoresConGato = mutableListOf<CompradorConGato>()\r\n        val buyerCatMap = mutableMapOf<String, String>() // Mapa para guardar CompradorId -> NombreGato\r\n\r\n        selectedBuyers.zip(selectedGatos) { comprador, gato ->\r\n            compradoresConGato.add(CompradorConGato(comprador, gato.nombre))\r\n            // Inserta el comprador en la tabla CompradorUser para este usuario\r\n            dbHelper.insertarCompradorDiario(comprador.id!!, user.id!!)\r\n            // Guarda la asociación en el mapa (already user-specific key)\r\n            buyerCatMap[comprador.id.toString()] = gato.nombre!!\r\n        }\r\n\r\n        // Guarda el mapa de asociación CompradorId -> NombreGato en SharedPreferences para este usuario (already user-specific)\r\n        guardarDailyBuyerCatMap(user.id!!, buyerCatMap)\r\n\r\n        // Guarda el timestamp de la generación (PER USER)\r\n        guardarUltimaGeneracionTimestamp(System.currentTimeMillis(), user.id!!) // Pass the user's ID here!\r\n\r\n        Log.d(\"VenderGato\", \"Generados y guardados ${compradoresConGato.size} compradores diarios con gatos para usuario ${user.id}.\")\r\n        return compradoresConGato\r\n    }\r\n\r\n\r\n    // --- Lógica para guardar y cargar la asociación CompradorId -> NombreGato interesado (en SP, por usuario) ---\r\n\r\n    // Guarda el mapa de asociación CompradorId -> NombreGato interesado en SharedPreferences para un usuario\r\n    private fun guardarDailyBuyerCatMap(userId: Int, map: Map<String, String>) {\r\n        val prefs = getSharedPreferences(KEY_DAILY_BUYER_CAT_MAP, MODE_PRIVATE)\r\n        val key = \"${KEY_DAILY_BUYER_CAT_MAP}_$userId\" // Clave única por usuario\r\n        val jsonObject = JSONObject(map as Map<*, *>).toString() // Convertir el mapa a JSON String\r\n        prefs.edit().putString(key, jsonObject).apply()\r\n        Log.d(\"VenderGato\", \"Guardado mapa CompradorId->NombreGato para usuario $userId: $jsonObject\")\r\n    }\r\n\r\n    // Carga el mapa de asociación CompradorId -> NombreGato interesado desde SharedPreferences para un usuario\r\n    private fun cargarDailyBuyerCatMap(userId: Int): Map<String, String> {\r\n        val prefs = getSharedPreferences(KEY_DAILY_BUYER_CAT_MAP, MODE_PRIVATE)\r\n        val key = \"${KEY_DAILY_BUYER_CAT_MAP}_$userId\" // Clave única por usuario\r\n        val jsonString = prefs.getString(key, null)\r\n\r\n        return if (jsonString.isNullOrEmpty()) {\r\n            emptyMap()\r\n        } else {\r\n            try {\r\n                val jsonObject = JSONObject(jsonString)\r\n                val map = mutableMapOf<String, String>()\r\n                jsonObject.keys().forEach { jsonKey ->\r\n                    map[jsonKey] = jsonObject.getString(jsonKey)\r\n                }\r\n                Log.d(\"VenderGato\", \"Cargado mapa CompradorId->NombreGato para usuario $userId: $map\")\r\n                map\r\n            } catch (e: Exception) {\r\n                Log.e(\"VenderGato\", \"Error al parsear el mapa CompradorId->NombreGato desde SharedPreferences para usuario $userId\", e)\r\n                emptyMap()\r\n            }\r\n        }\r\n    }\r\n\r\n    // Elimina el mapa de asociación CompradorId -> NombreGato interesado de SharedPreferences para un usuario\r\n    private fun limpiarDailyBuyerCatMap(userId: Int) {\r\n        val prefs = getSharedPreferences(KEY_DAILY_BUYER_CAT_MAP, MODE_PRIVATE)\r\n        val key = \"${KEY_DAILY_BUYER_CAT_MAP}_$userId\" // Clave única por usuario\r\n        prefs.edit().remove(key).apply()\r\n        Log.d(\"VenderGato\", \"Mapa CompradorId->NombreGato limpio para usuario $userId\")\r\n    }\r\n\r\n    // --- Lógica para el timestamp (en SP, global) ---\r\n\r\n    // Guardar el timestamp de la última generación de compradores (per user)\r\n    private fun guardarUltimaGeneracionTimestamp(timestamp: Long, userId: Int) {\r\n        val prefs = getSharedPreferences(KEY_LAST_GENERATION_TIMESTAMP_BASE, MODE_PRIVATE)\r\n        val key = \"${KEY_LAST_GENERATION_TIMESTAMP_BASE}_$userId\" // User-specific key\r\n        prefs.edit().putLong(key, timestamp).apply()\r\n        Log.d(\"VenderGato\", \"Timestamp de última generación guardado para user $userId: $timestamp\")\r\n    }\r\n\r\n    // Cargar el timestamp de la última generación de compradores (per user)\r\n    private fun cargarUltimaGeneracionTimestamp(userId: Int): Long {\r\n        val prefs = getSharedPreferences(KEY_LAST_GENERATION_TIMESTAMP_BASE, MODE_PRIVATE)\r\n        val key = \"${KEY_LAST_GENERATION_TIMESTAMP_BASE}_$userId\" // User-specific key\r\n        val timestamp = prefs.getLong(key, 0L) // Default to 0 if not found\r\n        Log.d(\"VenderGato\", \"Timestamp de última generación cargado para user $userId: $timestamp\")\r\n        return timestamp\r\n    }\r\n\r\n\r\n\r\n    // Resetear Compradores a media noche. Ahora requiere el usuario y usa la DB y SP.\r\n    private suspend fun updateRecyclerViewData(user: User) {\r\n        val nuevosCompradores = selectAndSaveNewDailyBuyers(user) // Pasa el usuario\r\n        withContext(Dispatchers.Main) {\r\n            currentDailyBuyersList = nuevosCompradores // Actualizar la lista in-memory\r\n            Toast.makeText(this@VenderGato, \"¡Medianoche alcanzada! Recargando compradores...\", Toast.LENGTH_SHORT).show()\r\n            adapter.actualizarLista(currentDailyBuyersList) // Actualizar adapter\r\n            adapter.selectedItemId = null // Deselect any previous buyer\r\n        }\r\n    }\r\n\r\n\r\n    // Modified selling logic using the activity's currentDailyBuyersList and interacting with DB\r\n    private fun resolverVenta() {\r\n        val compradorSeleccionadoId = adapter.selectedItemId\r\n        if (compradorSeleccionadoId != null && currentUser != null) {\r\n\r\n            val compradorSeleccionadoConGato = currentDailyBuyersList.find { it.comprador.id == compradorSeleccionadoId }\r\n\r\n            if (compradorSeleccionadoConGato != null) {\r\n                lifecycleScope.launch(Dispatchers.IO) { // Cambiado a IO para operaciones de DB\r\n                    val gatosUsuario = dbHelper.obtenerGatosByUser(currentUser!!)\r\n\r\n                    val gatoEncontrado = gatosUsuario.find { it.nombre == compradorSeleccionadoConGato.nombreGatoInteres }\r\n\r\n                    withContext(Dispatchers.Main) { // Volver al hilo principal para UI\r\n                        if (gatoEncontrado != null) {\r\n                            val dialogView = layoutInflater.inflate(R.layout.dialog_venta_completada, null)\r\n\r\n                            val builder = android.app.AlertDialog.Builder(this@VenderGato)\r\n                                .setView(dialogView)\r\n\r\n                            val dialog = builder.create()\r\n\r\n                            val mensaje = dialogView.findViewById<TextView>(R.id.mensajeVenta)\r\n                            val btnAceptar = dialogView.findViewById<Button>(R.id.btnAceptarVenta)\r\n\r\n                            mensaje.text = \"Has vendido un gato a ${compradorSeleccionadoConGato.comprador.nombre}\"\r\n\r\n                            btnAceptar.setOnClickListener {\r\n                                // Eliminar este comprador de la tabla CompradorUser para este usuario\r\n                                // para que desaparezca de la lista diaria.\r\n                                lifecycleScope.launch(Dispatchers.IO) {\r\n                                    dbHelper.eliminarCompradorDeUsuario(compradorSeleccionadoId, currentUser!!.id!!)\r\n                                    Log.d(\"VenderGato\", \"Eliminado comprador ${compradorSeleccionadoId} de la lista diaria de usuario ${currentUser!!.id!!}\")\r\n\r\n                                    // Ahora, actualizar la lista in-memory y el adapter en el hilo principal\r\n                                    withContext(Dispatchers.Main) {\r\n                                        currentDailyBuyersList = currentDailyBuyersList.filter { it.comprador.id != compradorSeleccionadoId }\r\n                                        adapter.actualizarLista(currentDailyBuyersList) // Actualiza el adapter con la nueva lista filtrada\r\n                                        adapter.selectedItemId = null\r\n                                    }\r\n                                }\r\n                                dialog.dismiss()\r\n                            }\r\n                            dialog.show()\r\n                        } else {\r\n                            Toast.makeText(this@VenderGato, \"No tienes un gato con el nombre que busca este comprador (${compradorSeleccionadoConGato.nombreGatoInteres})\", Toast.LENGTH_SHORT).show()\r\n                        }\r\n                    }\r\n                }\r\n\r\n            } else {\r\n                Toast.makeText(this, \"Error: Comprador seleccionado no encontrado en la lista actual.\", Toast.LENGTH_SHORT).show()\r\n            }\r\n        } else {\r\n            val message = if (compradorSeleccionadoId == null) \"Selecciona un comprador primero\" else \"Error: No se pudo cargar el usuario.\"\r\n            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/gatoshunter/VenderGato.kt b/app/src/main/java/com/example/gatoshunter/VenderGato.kt
--- a/app/src/main/java/com/example/gatoshunter/VenderGato.kt	(revision 1e13268dbf9155a363e57478248aac411c394b71)
+++ b/app/src/main/java/com/example/gatoshunter/VenderGato.kt	(date 1747677164643)
@@ -4,6 +4,7 @@
 import android.os.Parcelable
 import android.util.Log
 import android.widget.Button
+import android.widget.EditText
 import android.widget.TextView
 import android.widget.Toast
 import androidx.appcompat.app.AppCompatActivity
@@ -306,4 +307,73 @@
             Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
         }
     }
+
+    private fun mostrarDialogoVenta(compradorConGato: CompradorConGato) {
+        val dialogView = layoutInflater.inflate(R.layout.dialog_info_comprador, null)
+
+        val precioEditText = dialogView.findViewById<EditText>(R.id.precioEditText)
+        val btnVender = dialogView.findViewById<Button>(R.id.btnVender)
+        val btnCancelar = dialogView.findViewById<Button>(R.id.btnCancelar)
+
+        val dialog = android.app.AlertDialog.Builder(this)
+            .setView(dialogView)
+            .create()
+
+        btnVender.setOnClickListener {
+            val precioStr = precioEditText.text.toString()
+            val precio = precioStr.toDoubleOrNull()
+
+            if (precio == null || precio <= 0) {
+                Toast.makeText(this, "Introduce un precio válido", Toast.LENGTH_SHORT).show()
+                return@setOnClickListener
+            }
+
+            val comprador = compradorConGato.comprador
+
+            if (comprador.dinero >= precio) {
+                // Resta el precio al dinero del comprador
+                comprador.dinero -= precio
+
+                // Actualiza la BD en background
+                lifecycleScope.launch(Dispatchers.IO) {
+                    comprador.id?.let { it1 -> dbHelper.actualizarDineroComprador(it1, comprador.dinero) }
+                }
+
+                Toast.makeText(this, "Venta realizada por $precio €", Toast.LENGTH_SHORT).show()
+
+                // Cierra el diálogo
+                dialog.dismiss()
+
+                // Actualiza UI (elimina comprador vendido)
+                comprador.id?.let { it1 -> adapter.eliminarComprador(it1) }
+                adapter.selectedItemId = null
+                currentDailyBuyersList = currentDailyBuyersList.filter { it.comprador.id != comprador.id }
+
+            } else {
+                Toast.makeText(this, "El comprador no tiene suficiente dinero", Toast.LENGTH_SHORT).show()
+            }
+        }
+
+        btnCancelar.setOnClickListener {
+            dialog.dismiss()
+        }
+
+        dialog.show()
+    }
+    private fun intentarVenderDesdeClick(compradorConGato: CompradorConGato) {
+        lifecycleScope.launch(Dispatchers.Main) {
+            val prefs = applicationContext.getAppSharedPreferences()
+            val user = prefs.getUserAsync("Usuario")!!
+            val gatosUsuario = dbHelper.obtenerGatosByUser(user)
+
+            val gatoEncontrado = gatosUsuario.find { it.nombre == compradorConGato.nombreGatoInteres }
+
+            if (gatoEncontrado == null) {
+                Toast.makeText(this@VenderGato, "No tienes un gato con ese nombre", Toast.LENGTH_SHORT).show()
+                return@launch
+            }
+
+            mostrarDialogoVenta(compradorConGato)
+        }
+    }
 }
\ No newline at end of file
